# -*- coding: utf-8 -*-
"""result.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1bJnKnYAP8uwPgupSS3vcxrw8GL5B655-
"""

from keras import applications
from keras.preprocessing.image import ImageDataGenerator
from keras import optimizers
from keras.models import Sequential, Model
from keras.layers import Dropout, Flatten, Dense, GlobalAveragePooling2D
from keras import backend as k
from keras.callbacks import ModelCheckpoint, LearningRateScheduler, TensorBoard, EarlyStopping
import numpy as np

img_width, img_height = 256, 256
train_data_dir = "training_set"
batch_size = 16
epochs = 10

model = applications.VGG19(weights = "imagenet", include_top=False, input_shape = (img_width, img_height, 3))

# Freeze the layers which you don't want to train. Here I am freezing the first 5 layers.
for layer in model.layers[:-2]:
    layer.trainable = False

#Adding custom Layers
x = model.output
x = Flatten()(x)
x = Dense(1024, activation="relu")(x)
x = Dropout(0.5)(x)
x = Dense(1024, activation="relu")(x)
predictions = Dense(2, activation="softmax")(x)

# creating the final model
model_final = Model(input = model.input, output = predictions)

# compile the model
model_final.compile(loss = "categorical_crossentropy", optimizer = optimizers.SGD(lr=0.0001, momentum=0.9), metrics=["accuracy"])

#Load the pretrainted weights
model_final.load_weights('vgg16_hand_new.hdf5')

from keras.preprocessing import image
from tqdm import tqdm

def path_to_tensor(img_path):
    # loads RGB image as PIL.Image.Image type
    img = image.load_img(img_path, target_size=(256, 256))
    # convert PIL.Image.Image type to 3D tensor with shape (256, 256, 3)
    x = image.img_to_array(img)
    # convert 3D tensor to 4D tensor with shape (1, 256, 256, 3) and return 4D tensor
    return np.expand_dims(x, axis=0)

def paths_to_tensor(img_paths):
    list_of_tensors = [path_to_tensor(img_path) for img_path in tqdm(img_paths)]
    return np.vstack(list_of_tensors)

class_names=['glove','hand']

def predict_category(img_path):
  """
  Predicts the catogery of the ip image
  ip is the path to the image
  op is the category to which the image belongs to
  """
  tensor = path_to_tensor(img_path)
  # WE need to send a tensor to find the bottelneck feature so cnverting the image to a tensor


  prediction = model_final.predict(tensor)

  return np.argmax(prediction)

import matplotlib.image as mpimg
import matplotlib.pyplot as plt
# %matplotlib inline
def pretty_predict(img_path):

  prediction_binary = predict_category(img_path)
  cat = class_names[prediction_binary]
  img=mpimg.imread(img_path)
  plt.imshow(img)
  print("The above image is of a {}".format(cat))
